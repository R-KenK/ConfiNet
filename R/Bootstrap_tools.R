
# Bootstrap "object" specific tools ---------------------------------------

#' Keep bootstrap parameters as attributes
#' Internal use in Boot_scans(). Add "method", "keep", "mode", "output" attributes to be more easily retrieved by the get function
#'
#' @param Bootstrap Boot_scans() intermediate output
#' @param method Character scalar, specify if the function should use a whole group or a focal scan sampling method (or both).
#' @param keep logical. Indicate if the original "theoretical" scan should be kept track of.
#' @param mode Character scalar, specifies how igraph should interpret the supplied matrix. See also the weighted argument, the interpretation depends on that too. Possible values are: directed, undirected, upper, lower, max, min, plus. See details \link[igraph]{graph_from_adjacency_matrix}.
#' @param output Character scalar, specify if the function should return the list of scans, or reduce them into the bootstrapped adjacency matrix
#'
#' @return list which structure depends on chosen parameters, with parameters stored as attributes.
#' @export
#'
#' @examples
#' #Internal
Bootstrap_add.attributes<- function(Bootstrap,method,keep,mode,output){
  attr(Bootstrap,"method")<- method;
  attr(Bootstrap,"keep")<- keep;
  attr(Bootstrap,"mode")<- mode;
  attr(Bootstrap,"output")<- output;
  Bootstrap
}

#' Retrieve specific data from Boot_scans() output
#' Subset rich Bootstrap output choosing what's needed
#'
#' @param what character scalar, data type requested
#' @param format character scalar, output format type requested ("both","list" or "adjacency").
#'
#' @return list which structure depends on chosen data type and Bootstrap attributes
#' @export
#'
#' @examples
#'
#' set.seed(42)
#'
#' n<- 5;nodes<- letters[1:n];
#' Adj<- matrix(data = 0,nrow = n,ncol = n,dimnames = list(nodes,nodes))
#' Adj[non.diagonal(Adj)]<- sample(0:42,n*(n-1),replace = TRUE)
#' Adj
#'
#' focal.list<- sample(nodes,42,replace = TRUE)
#' Bootstrap<- Boot_scans(Adj,3,total_scan = 42,focal.list = focal.list,
#'                        scaled = FALSE,obs.prob=0.7,keep=TRUE,
#'                        method = "group",mode = "directed",output = "list")
#' Boot_get.list(Bootstrap,"theoretical")
#' Boot_get.list(Bootstrap,"observed")
#'
#' Bootstrap<- Boot_scans(Adj,3,total_scan = 42,focal.list = focal.list,
#'                        scaled = TRUE,obs.prob=0.7,keep=TRUE,
#'                        method = "both",mode = "directed",output = "all")
#' Boot_get.list(Bootstrap,"observed","both")
#' Boot_get.list(Bootstrap,"observed","adjacency")
#' Boot_get.list(Bootstrap,"observed","list")
Boot_get.list<- function(Bootstrap,what=c("group","focal","theoretical","observed"),format = c("both","list","adjacency")){
  what<- match.arg(what)
  format<- match.arg(format)

  method<- attr(Bootstrap,"method");
  keep<- attr(Bootstrap,"keep");
  output<- attr(Bootstrap,"output");

  if((what %in% c("theoretical","observed")) & (keep==FALSE)) {
    warning(paste0("keep was set to FALSE in Bootstrap. Do you mean to retrieve group?"))
    what<- "group";
  }
  if((what %in% c("group","focal")) & (method!="both" & method!=what)) {stop("Requested List doesn't exist in provided Bootstrap.")}
  if(output=="list"&format=="adjacency") {stop("WIP.")}

  switch(output,
         "list" =  switch(method,
                          "group" = if(keep){
                            lapply(Bootstrap,function(B) lapply(B,function(l) l[[what]]))
                          }else{
                            lapply(Bootstrap,function(B) lapply(B,function(l) l))
                          },
                          "focal" = lapply(Bootstrap,function(B) lapply(B,function(l) l)),
                          "both" = {
                            if(keep){
                              switch(what,
                                     "group" = ,
                                     "focal" = lapply(Bootstrap,function(B) lapply(B,function(l) l[[what]])),
                                     "theoretical" = ,
                                     "observed" = lapply(Bootstrap,function(B) lapply(B,function(l) l[["group"]][[what]])),
                              )
                            }else{
                              lapply(Bootstrap,function(B) lapply(B,function(l) l[[what]]))
                            }
                          }
         ),
         "adjacency" = switch(method,
                              "group" = if(keep){
                                lapply(Bootstrap,function(B) B[[what]])
                              }else{
                                lapply(Bootstrap,function(B) B)
                              },
                              "focal" = lapply(Bootstrap,function(B) B),
                              "both" = {
                                if(keep){
                                  switch(what,
                                         "group" = ,
                                         "focal" = lapply(Bootstrap,function(B) B[[what]]),
                                         "theoretical" = ,
                                         "observed" = lapply(Bootstrap,function(B) B[["group"]][[what]]),
                                  )
                                }else{
                                  lapply(Bootstrap,function(B) B[[what]])
                                }
                              }
         ),
         "all" = {
           all<- list(
             list = switch(method,
                           "group" = if(keep){
                             lapply(Bootstrap,function(B) lapply(B$list,function(l) l[[what]]))
                           }else{
                             lapply(Bootstrap,function(B) lapply(B$list,function(l) l))
                           },
                           "focal" = lapply(Bootstrap,function(B) lapply(B$list,function(l) l)),
                           "both" = {
                             if(keep){
                               switch(what,
                                      "group" = ,
                                      "focal" = lapply(Bootstrap,function(B) lapply(B$list,function(l) l[[what]])),
                                      "theoretical" = ,
                                      "observed" = lapply(Bootstrap,function(B) lapply(B$list,function(l) l[["group"]][[what]])),
                               )
                             }else{
                               lapply(Bootstrap,function(B) lapply(B$list,function(l) l[[what]]))
                             }
                           }
             ),
             adjacency = switch(method,
                                "group" = if(keep){
                                  lapply(Bootstrap,function(B) B$adjacency[[what]])
                                }else{
                                  lapply(Bootstrap,function(B) B$adjacency)
                                },
                                "focal" = lapply(Bootstrap,function(B) B$adjacency),
                                "both" = {
                                  if(keep){
                                    switch(what,
                                           "group" = ,
                                           "focal" = lapply(Bootstrap,function(B) B$adjacency[[what]]),
                                           "theoretical" = ,
                                           "observed" = lapply(Bootstrap,function(B) B$adjacency[["group"]][[what]]),
                                    )
                                  }else{
                                    lapply(Bootstrap,function(B) B$adjacency[[what]])
                                  }
                                }
             )
           )
           switch(format,
                  "both" = all,
                  "list" = all$list,
                  "adjacency" = all$adjacency
           )
         }
  )
}

#' Row bind list of data frames
#' wrapper to one-function do.call rbind over a lapply list
#'
#' @param X a list. See details \link[base]{lapply}.
#' @param FUN a function to subset data frames (or data tables). See details \link[base]{lapply}.
#'
#' @return a row bound data frame
#' @export
#'
#' @examples
#' set.seed(42)
#'
#' X<- lapply(1:3,function(i) list(int = 42,df = data.frame(x = runif(10,0,1),y = runif(10,0,1))))
#' rbind_lapply(X,function(x) x$df)
rbind_lapply<- function(X,FUN){
  do.call(rbind,lapply(X = X,FUN = FUN))
}

#' Bootstrap specific progress bar
#' Provide feedbacks on the simulation testing situation (which parameters, which combination of parameters over the whole list). Internal use.
#'
#' @param p integer, index of the current combination of parameters within parameters.list.
#' @param parameters.list data frame of parameters for all the simulations
#'
#' @return display some feedbacks on the simulation testing situation (which parameters, which combination of parameters over the whole list).
#' @export
#'
#' @examples
#' #Internal use in Simulation_script.R.
boot_progress.param<- function(p,parameters.list = parameters.list){
  cat(paste0("obs.prob = ",attr(parameters.list[[p]]$obs.prob,"name")
             ," - focal.list = ",attr(parameters.list[[p]]$focal.list,"name"),
             " - mode = ",attr(parameters.list[[p]]$mode,"name")," (",p,"/",length(parameters.list),")","\n"))
}

#' Retrieve specific simulation parameters of given Bootstrap
#' Internal use. To ease the recollection of a given bootstrap performed through Boot_scans() iterations alongside a parameters.list
#'
#' @param parameters a list containing a combination of obs.prob, focal.list, and mode parameters. Element of parameters.list
#'
#' @return a data frame referencing the simulation parameters
#' @export
#'
#' @examples
#' #Internal use in Simulation_script.R.
Boot_get.param<- function(parameters){
  data.frame(obs.prob = as.factor(attr(parameters$obs.prob,"name")),
             focal.list = as.factor(attr(parameters$focal.list,"name")),
             mode = as.factor(ifelse(is.null(attr(parameters$mode,"name")),parameters$mode,attr(parameters$mode,"name")))
  )
}

#' Calculate the correlation coefficient between "flattened" adjacency matrices
#' Provide the correlation coefficient between the theoretical adjacency matrix and either the empirical one from group or focal method
#'
#' @param Bootstrap.list an output of Boot_scan()
#' @param n.boot number of Bootstrap to go through
#' @param what character scalar, indicate if the function should output the coefficient between the theoretical adjacency matrix and either the empirical one from group or focal method
#'
#' @return a vector of correlation coefficients
#' @export
#'
#' @importFrom stats cor
#'
#' @examples
#' #Internal use in Simulation_script.R.
adjacency_cor<- function(Bootstrap.list,what = c("observed","focal"),n.boot = length(Bootstrap.list)){
  what<- match.arg(what)
  sapply(1:n.boot,  # needs function to gather and structure in a data frame
         function(b) {
           stats::cor(c(Boot_get.list(Bootstrap.list,"theoretical","adjacency")[[b]]),   # c() flattens the matrix to consider it like a vector
                      c(Boot_get.list(Bootstrap.list,what,"adjacency")[[b]]))
         }
  )
}
# HERE IMPLEMENT OTHER STATISTICAL APPROACHES: i.e. NETWORK DISTANCES, METRICS CORRELATION


# Simulation workflow tools -----------------------------------------------

#' Title
#'
#' @param Adj
#' @param total_scan
#' @param n.cores
#' @param cl
#'
#' @return
#' @export
#'
#' @examples
#' #Internal use in Simulation_script.R.
initialize_parameters<- function(Adj,total_scan,n.cores=(parallel::detectCores()-1),cl=NULL){
  OBS.PROB<- list(trait.pos = obs.prob_bias(Adj = Adj,obs.prob_fun = prod,bias_fun = NULL,reverse = FALSE),
                  trait.neg = obs.prob_bias(Adj = Adj,obs.prob_fun = function(i,j) 1/prod(i,j),bias_fun = NULL,reverse = FALSE),
                  network.pos = obs.prob_bias(Adj = Adj,obs.prob_fun = prod,
                                              bias_fun = function(node) igraph::strength(igraph::graph.adjacency(Adj,weighted = TRUE))[node],
                                              reverse = FALSE),
                  network.neg = obs.prob_bias(Adj = Adj,obs.prob_fun = prod,
                                              bias_fun = function(node) 1/igraph::strength(igraph::graph.adjacency(Adj,weighted = TRUE))[node],
                                              reverse = FALSE)
  )
  OBS.PROB<- c({unb<- seq(0.1,0.9,by = 0.2);names(unb)<- paste0("unbiased_",unb);as.list(unb)},OBS.PROB) # c() over two lists makes them flat while allowing for shorter calls
  MODE<- if(identical(Adj,t(Adj))) {as.list(c("max"))} else  {as.list(c(directed = "directed",max = "max",min = "min",plus = "plus"))}
  FOCAL.LIST<- list(random = sample(rownames(Adj),total_scan,replace = TRUE),  # consider checking if can be implemented for each boot (leaving it NULL?)
                    even = rep_len(rownames(Adj),length.out = total_scan),
                    biased = "TO IMPLEMENT")

  parameters.comb<- expand.grid(
    list(mode = 1:length(MODE),
         focal.list = 1:length(FOCAL.LIST[1:2]),
         obs.prob = 1:length(OBS.PROB)
    )
  )

  if(is.null(cl)) {cl<- snow::makeCluster(n.cores);doSNOW::registerDoSNOW(cl);on.exit(snow::stopCluster(cl))} # left to avoid error if the function is used alone, but should probably be used internally from Boot_scans() now.
  parameters.list<- foreach::`%dopar%`(
    foreach::foreach(p=1:nrow(parameters.comb)),
    list(
      obs.prob = {
        obs.prob<- OBS.PROB[[parameters.comb[p,"obs.prob"]]];
        attr(obs.prob,"name")<- names(OBS.PROB)[parameters.comb[p,"obs.prob"]];
        obs.prob
      },
      focal.list = {
        focal.list<- FOCAL.LIST[[parameters.comb[p,"focal.list"]]];
        attr(focal.list,"name")<- names(FOCAL.LIST)[parameters.comb[p,"focal.list"]];
        focal.list
      },
      mode = {
        mode<- MODE[[parameters.comb[p,"mode"]]];
        attr(mode,"name")<- names(MODE)[parameters.comb[p,"mode"]];
        mode
      }
    )
  )
  parameters.list
}

#' Title
#'
#' @param B
#' @param Bootstrap.list
#' @param parameters.list
#'
#' @return
#' @export
#'
#' @examples
#' #Internal use in Simulation_script.R.
Get.data<- function(B,Bootstrap.list,parameters.list){
  rbind_lapply(seq_along(Bootstrap.list),
               function(b){
                 rbind(data.frame(Network = B,boot = b,method = "group",
                                  Boot_get.param(parameters.list[[b]]),
                                  cor = adjacency_cor(Bootstrap = Bootstrap.list[[b]],what = "observed")),
                       data.frame(Network = B,boot = b,method = "focal",
                                  Boot_get.param(parameters.list[[b]]),
                                  cor = adjacency_cor(Bootstrap = Bootstrap.list[[b]],what = "focal")))
               }
  )
}
